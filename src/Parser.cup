package lang.parser;

import java.io.*;
import java.util.*;
import java_cup.runtime.Symbol;
 
parser code {:
	 
	public Map<String,Boolean> map = new HashMap<String,Boolean>();
	public Map<String, Predicate> predicates = new HashMap<String, Predicate>();
	
	public static Lexer makeLexer(String input) throws Exception {
		return new Lexer(new StringReader(input));
	}
	
	public static Parser makeParser(String input) throws Exception {
		final Parser parser = new Parser(makeLexer(input));
		parser.predicates.put("and", new Predicate(){
			@Override public boolean eval(List<?> args) {
				boolean res = true;
				for(Object o : args){
					res = res & parser.toBool(o);
				}
				return res;
				}
		});
		return parser;
	}
	
	public boolean toBool(Object val) {
		if( val instanceof Float) {
			return (float)val != 0f;
	  	}
	 	else if( val instanceof Boolean) {
			return (boolean)val;
		}
		return false;
	}
	
	public static Object parseString(String input) throws Exception {
		final Parser parser = Parser.makeParser(input);
		Symbol result = parser.parse();
		return result.value;
	}
	
:}

// Rules

terminal NOT, AND, OR, COND, BICOND, P1,
		 P2, EOL, EQ, COMMA;
terminal Boolean valor;
terminal String id;
terminal Float num;
non terminal Boolean expresion;
non terminal List expressions;
non terminal String asig;
non terminal List input;
non terminal List lista_expresiones;
non terminal Boolean pred;

precedence left BICOND;
precedence left COND;
precedence left OR;
precedence left AND;
precedence left NOT;
precedence left P1, P2;

input ::= asig:a EOL {: RESULT = new ArrayList<>(); RESULT.add(a); :}
		| expressions:e EOL {: RESULT = new ArrayList<>(); RESULT.add(e); :}
		| input:s asig:a EOL {: RESULT = s; s.add(a); :}
		| input:s expresion:e EOL {: RESULT = s; s.add(e); :}
		| pred:p EOL {: RESULT = new ArrayList<>(); RESULT.add(p); :}
		| input:s pred:p EOL {: RESULT = s; s.add(p); :}
		;
asig ::= id:i EQ expresion:e 
			{: parser.map.put(i,e); RESULT = i + " = " + e.toString();:}
		;
expresion ::= valor:v {: RESULT = v; :}
		| id:i {: RESULT = parser.map.get(i); :}
		| num:n {: RESULT = parser.toBool(n); :}
		| NOT expresion:e 
			{: RESULT = !e; :}
		| P1 expresion:e P2
			{: RESULT = e; :}
		| expresion:e1 AND expresion:e2 
			{: RESULT = new Boolean(Boolean.logicalAnd(e1,e2)); :}
		| expresion:e1 OR expresion:e2
			{: RESULT = new Boolean(Boolean.logicalOr(e1,e2)); :}
		| expresion:e1 COND expresion:e2
			{: RESULT = new Boolean(Boolean.logicalOr(!e1,e2)); :}
		| expresion:e1 BICOND expresion:e2
			{: RESULT = e1.equals(e2); :}
		;
pred ::= id:i P1 lista_expresiones:l P2
			{: RESULT = parser.predicates.get(i).eval(l); :}
		;
lista_expresiones ::= expresion:e {: RESULT = new ArrayList<>(); RESULT.add(e); :}
				| lista_expresiones:l COMMA expresion:e
					{: RESULT = l; l.add(e); :}
				;